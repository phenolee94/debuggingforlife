
import numpy as np
import pandas as pd
import torch
from torch import nn
from torch.nn import functional as F

asco_X, basi_X = np.load('asco_encoded.npy'), np.load('basi_encoded.npy')
asco_Y, basi_Y = [0] * np.shape(asco_X)[0], [1] * np.shape(basi_X)[0]

seqs = np.concatenate((asco_X, basi_X))
phy = asco_Y + basi_Y

print(seqs)

df = pd.DataFrame(list(zip(seqs, phy)), columns=['Sequences', 'Phylum'])
data = df.sample(frac=1)

x, y = np.vstack(data['Sequences']).astype(np.float32), np.vstack(data['Phylum']).astype(np.float32)

from torch.utils.data import Dataset, DataLoader
class dataset(Dataset):
    def __init__(self, x, y):
        self.x = torch.tensor(x, dtype=torch.float32)
        self.y = torch.tensor(y, dtype=torch.float32)
        self.length = self.x.shape[0]
    def __getitem__(self, idx):
        return self.x[idx], self.y[idx]

    def __len__(self):
        return self.length

trainset = dataset(x, y)
trainloader = DataLoader(trainset, batch_size=4, shuffle=False)


class Net(nn.Module):
    def __init__(self, input_shape):
        super(Net,self).__init__()
        self.fc1 = nn.Linear(input_shape, 400)
        self.fc2 = nn.Linear(400, 200)
        self.fc3 = nn.Linear(200, 1)

    def forward(self, x):
        x = torch.relu(self.fc1(x))
        x = torch.relu(self.fc2(x))
        x = torch.sigmoid(self.fc3(x))
        return x

learning_rate = 0.01
epochs = 500
model = Net(input_shape=650)
optimizer = torch.optim.SGD(model.parameters(), lr=learning_rate)
loss_fn = nn.BCELoss()

# forward loop
losses = []
accuracy = []

